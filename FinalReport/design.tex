\section{Design}
The concept for the GeoLog originally came from Dr. Andrew D. Wickert (seen in figure 
\ref{fig:andrewWickert}), which came to ReykjavÃ­k University's Mechatronics class for 
help developing his design of a low cost, low power datalogger\cite{ALog-BottleLogger}. 
He had two problems needed to be solved. First was to minimize the power consumption of the device he had already developed and the latter was to have means of getting the data
back without having to travel trough difficult terrain. Decision was made to help Andrew 
improve the latter with emphasis on making the system as modular as possible. 

\begin{figure}
\centering
\includegraphics[width=0.4\linewidth]{graphics/andrewWickert}
\caption{Andrew Wickert\label{fig:andrewWickert}\cite{andrewWickert}}
\end{figure}

The GeoLog datalogger was designed in nine phases. Phases seven to eight were iterated
until the product was ready for deployment.

\begin{itemize}
    \item{Phase 1:} Initial brainstorming and high level design phase.
    \item{Phase 2:} Hardware selection phase, where hardware was selected and ordered.
    \item{Phase 3:} Software design phase, where the classes and interfaces were designed.
    \item{Phase 4:} Hardware hacking phase, trial and error in software writing for the
                    Wixels\cite{wixel} and the GSM/GPRS module\cite{SM5100B}.
    \item{Phase 5:} Building phase, where hardware were assembled.
    \item{Phase 6:} Software integration phase, all the software integrated to one.
    \item{Phase 7:} Field testing phase, testing of the system in real life environment.
    \item{Phase 8:} Fixing phase, fixing bugs found in the field testing phase.
    \item{Phase 9:} Deployment phase, system is functional and can be deployed. 
\end{itemize}

\textit{\textcolor{red}{Assumptions stated (There are always some)}}


\subsection{Hardware}
\begin{figure}
\centering
\includegraphics[width=0.5\linewidth]{graphics/HardwareMDD}
\caption{Hardware Module Design Diagram\label{fig:HardwareMDD}}
\end{figure}

The hardware is divided to sensor modules and the mother hub. The sensor modules 
designed for this system were three wireless temperature sensors using Wixel\cite{wixel}
for means of communications. The mother hub consists of a Arduino Mega\cite{arduinoMega}
that communicates with the sensor modules with a Wixel, collects the data 
and sends it to a HTTP server via the GSM/GPRS module\cite{SM5100B}. 
Figure \ref{fig:HardwareMDD} shows how the hardware is set up. 

\subsubsection{Sensor module}
The sensor module is based on Wixel\cite{wixel} that reads sensor value on one of it's
analog inputs when the mother hub calls for reading. To save energy the sensor module does
not send any data until it's id is called by the mother hub. The sensor module then 
gathers several readings from the sensor over a short period of time and sends back the 
average reading of the data collected then falls back to suspend mode until the mother 
hub calls for data again. Electrical schematic diagram of the sensor module can
be seen in figure \ref{fig:sensormodule_schematic}.

\subsubsection{Mother hub}
The mother hub is based on Arduino Mega 2560\cite{arduinoMega} which can be switched out 
for Andrew's Bottle Logger\cite{ALog-BottleLogger}, a Wixel\cite{wixel} used for 
communicating with the wireless sensor modules and a SM5100B GSM/GPRS 
module\cite{SM5100B}. The mother hub gathers data from the Wireless sensor modules via 
the onboard Wixel by calling them by id and wait till corresponding sensor module answers
with newly gathered sensor data. The data gathered is then saved to its onboard EEPROM
and at a preset time the data is sent to HTTP server via GPRS where it can be processed 
by the researcher. Electrical schematic diagram of the mother hub can be seen in figure 
\ref{fig:motherhub_schematic}.

\subsection{Software}
\begin{figure}
\centering
\includegraphics[width=0.6\linewidth]{graphics/Layering}
\caption{Layered Design Diagram of the system\label{fig:Layering}}
\end{figure}

When designing the software, modularity was the main interest. The design aims for making
it as easy as possible to implement new ways of communications, sensors and storage. This 
is done by building the software up of three interfaces the user needs to implement if for
example another means of communications is needed. The system comes with two ways of
communications to the outside world, a SMS gateway and a GPRS HTTP gateway. It comes also with one way of storing data, to the EEPROM and one way of communicating to wireless sensors. Figure \ref{fig:Layering} shows the layered design of the software. 

To take a closer look in to the software and how the interfaces work see the class diagram
shown in figure \ref{fig:ClassDiagram}. Next sections will describe more thoroughly how each 
module works under the hood. All code is written in C++ except the HTTP server which is 
written in Python/Flask-Restful.

\subsubsection{Sensor Service interface}
The sensor service is an interface the developer needs to implement for every new kind of
sensor module. The sensor service interface has three virtual functions that the developer
needs to implement by inheriting from the SensorService class.The functions needing implementation are the following:
\begin{itemize}
    \item \textbf{int getSensorData(int sensorId)}
        \begin{itemize}
            \item Takes in the id of the sensor and returns the raw value.
        \end{itemize}
    \item \textbf{int sendDataToSensor(String data)}
        \begin{itemize}
            \item Takes in data to send to sensor and returns 0 for OK and -1 for error.
                  This could be used to remote calibrate sensor.
        \end{itemize}
    \item \textbf{int setDateTime(long DateTime)}
        \begin{itemize}
            \item Takes in UNIX date/time for setting the time on the sensor if needed.
        \end{itemize}
\end{itemize}
The Sensor service now implemented is the WixelSensorService. This service communicates 
with the Wixel Sensor Modules, converts the raw data to a value of interest like 
temperature and finally parses the converted data to Json\cite{json} strings. Sample
of Json parsed data can be seen in figure \ref{fig:JsonTemp}. Pseudocode of the 
getSensorData function can be seen in listing \ref{pseodoWixelSensorService}.


\begin{lstlisting}[frame=single, label=pseodoWixelSensorService, caption={Pseudocode of WixelSensorService getSensorData() function}]
Function(getSensorData(sensorId)):
    define wixelSerialPort as desired serial port
    define TimeOut as desired timeout in milliseconds
    define startTime as current time in milliseconds
    define data as 0;
    while data equals 0 or ((current time - startTime) > TimeOut:
        write sensorId to wixelSerialPort
        wait for 100 milliseconds
        if wixelSerialPort read buffer is not empty:
            data = data read from wixelSerialPort
            flush wixelSerialPort
        end if
    end while
    return data converted to celsius
end Function(getSensorData)
\end{lstlisting}

\begin{figure}
\centering
\includegraphics{graphics/JsonTemp}
\caption{Json\cite{json} string received from the WixelSensorService\label{fig:JsonTemp}}
\end{figure}

\subsubsection{Storage Service interface}
The storage service is an interface the developer needs to implement if a new way of
storing data is needed. The storage service interface has four virtual functions the developer needs to implement by inheriting from the StorageService class. The functions needing implementation are the following:
\begin{itemize}
    \item \textbf{int save(String data)}
        \begin{itemize}
            \item Takes in data in String format and saves it to storage medium. 
                  Returns number of bytes saved, returns -1 if not enough space.
        \end{itemize}
    \item \textbf{String load()}
        \begin{itemize}
            \item Loads all data in memory and returns it in string format.
        \end{itemize}
    \item \textbf{int erase()}
        \begin{itemize}
            \item Erases all data from storage medium. Returns number of bytes
                  free after erase.
        \end{itemize}
    \item \textbf{bool isFreeSpcace(int dataSize)}
        \begin{itemize}
            \item Takes in size of data to be saved in bytes. Returns true if enough 
                  space is available, false if not.
        \end{itemize}
\end{itemize}
The Storage Service now implemented is the LocalStorageService. This service stores data 
to the Arduino's EEPROM. The Arduino Mega 2560 has 4096 bytes of 
EEPROM \cite{arduinoMega}. The LocalStorageService stores the data as series of Json 
strings. A typical use of the LocalStorageService is first to use the isFreeSpace() functionto check if enough space is available for the data to be stored. If space is enough the save() function is used to save the data to the EEPROM. If space is not available the developer has to take some action like loading all existing data using the load() function, send the data to the HTTP server before using the erase() function to erase the EEPROM for new data. Pseudocode of the save(), load() and erase() functions can be seen in listings \ref{pseodoLocalStorageService}

\begin{lstlisting}[frame=single, label=pseodoLocalStorageService, caption={Pseudocode of LocalStorageService save(), load() and erase() functions}]
Function(save(data)):
    define iterator as 0
    define i = 0
    for i < EEPROM size:
        read byte i from EEPROM
        if byte i equals 0:
            break
        end if
        iterator = iterator + 1
        i = i + 1
    end for
    if not enough space for data:
        return -1
    else:
        define dataSize as 0
        define j as 0
        for j < data size in bytes:
            if iterator >= (EEPROM size -1):
                break
            end if
            write byte at index j in data to EEPROM address that equals iterator
            iterator = iterator + 1
            dataSize = dataSize +1
        end for
        write ',' to EEPROM address corresponding to iterator
        dataSize = dataSize + 1
        return dataSize
    end if
end Function(save(data))

Function(load):
    define data as string
    define i as 0
    define letter
    for i < EEPROM size:
        letter = byte at EEPROM address that equals i
        if letter equals 0:
            break
        end if
        append letter to data
    end for
    return data
end Function(load)

Function(erase):
    define counter as 0
    define i as 0
    for < EEPROM size:
        counter = counter + 1
        write 0 to EEPROM address that equals i
    end for
    if counter not equals EEPROM size:
        return -1
    else:
        return counter
    end if
Function(erase)
\end{lstlisting}
\subsubsection{Network Gateway interface}
The network gateway is an interface the developer needs to implement for each new way 
of communications with the outside world. The network gateway interface has five virtual 
functions the developer needs to implement by inheriting from the NetworkGateway class.
The functions needing implementation are the following:
\begin{itemize}
    \item \textbf{bool connectToNetwork()}
        \begin{itemize}
            \item Connects to network. Returns true if connected, false if not
                  connected to network.
        \end{itemize}
    \item \textbf{bool connected()}
        \begin{itemize}
            \item Checks if connected to network. Returns true if connected, false
                  if not connected.
        \end{itemize}
    \item \textbf{int sendData(String address, String data)}
        \begin{itemize}
            \item Sends given data to given address. Returns number of bytes sent, -1 if 
                  error sending data.
        \end{itemize}
    \item \textbf{String reciveData(String address)}
        \begin{itemize}
            \item Gets data from given address. Returns the data.
        \end{itemize}
     \item \textbf{long getTime()}
        \begin{itemize}
            \item Gets the current time/date from the network. Returns the time in UNIX time/date as long.
        \end{itemize}
\end{itemize}
The Network Gateways now implemented are the SmsGateway and the GprsGateway. The 
GprsGatway is based on code from Toby Fox\cite{tobek} and the SmsGateway utilizes the
SerialGSM library from Meir Michanie\cite{meirm}. Since SMSGateway is not yet fully
developed the GprsGateway will be described here.

The GprsGateway sends gathered sensor data as Json objects via HTTP to a HTTP API
mentioned below. The GprsGateway uses AT commands\cite{ATcommands} to control the GPRS module. A typical use of the GprsGateway is first to check if the system is online by calling the connected() function. If the system is offline the 
connectToNetwork() function is called to connect to the GPRS network. When connected 
there are three functions to choose from; sendData(), receiveData and getTime. The 
sendData() function takes in the data as Json string and posts it to a given HTTP address
as REST\cite{rest} message. The receiveData() function receives data from a given HTTP
address. This can be used to update or change settings of the GeoLog. The getTime()function is used to get the current time from the network to sync the onboard clock.
Pseudocode for connectToNetwork() and sendData() functions can be seen in listings 
\ref{pseodoGprsGateway}

\begin{lstlisting}[frame=single, label=pseodoGprsGateway, caption={Pseudocode of GprsGateway connectToNetwork() and sendData() functions}]
Function(connectToNetwork):
    boot up GPRS module
    send "AT+CGATT=1" to the GPRS module
    wait for OK from the GPRS module
    if not received OK from GPRS module:
        return false
    end if
    send "AT+CGDCONT=1, IP, YOUR_APN" to the GPRS module
    wait for OK from the GPRS module
    if not received OK from GPRS module:
        return false
    end if
    send "AT+CGACT=1,1" to the GPRS module
    wait for OK from the GPRS module
    if not received OK from GPRS module:
        return false
    end if
    send "AT+SDATACONF=1, TCP, YOUR_SERVER_IP_ADDRESS, YOUR_SERVER_PORT_NUMBER"
    wait for OK from the GPRS module
    if not received OK from GPRS module:
        return false
    end if
    send "AT+SDATASTART=1,1" to the GPRS module
    wait for OK from the GPRS module
    if not received OK from GPRS module:
        return false
    end if
    return true
end Function(connectToNetwork)

Function(sendData(address, data)):
    define timeOut as desired timeout in milliseconds
    define data as "POST /geolog HTTP/1.1
                    Host: YOUR_HTTP_SERVER_ADDRESS
                    Content-Type: application/json
                    Content-Length: SIZE_OF_DATA_IN_BYTES

                    contents of data"
    if not connected to network:
        connectToNetwork()
    end if
    define inTime as time now in milliseconds
    while (time now in milliseconds - inTime) < timeOut:
        send "AT+SDATASTATUS=1" to the GPRS module
        get socketstatus from GPRS module
        if not received OK from GPRS module:
            return -1
        end if
        if socketstatus = "+SOCKSTATUS:  1,0,0104,0,0,0":
            wait for 1000 milliseconds
        else if socketstatus = "+SOCKSTATUS:  1,1,0102,0,0,0":
            break
        else:
            return -1
        end if
    end while
    define packetlength as size of data in bytes
    send "AT+SDATATSEND=1, packetLength\r" to the GPRS module
    if not received ">" from the GPRS module:
        return -1
    end if
    send data to the GPRS module
    send ctrl-z to the GPRS module
    if not received OK from GPRS module:
        return -1
    end if    
    define inTime as time now in milliseconds
    while (time now in milliseconds - inTime) < timeOut:
        send "AT+SDATASTATUS=1" to the GPRS module
        get socketstatus from GPRS module
        if socketstatus equals "+STCPD:1":
             get socketstatus from GPRS module
        end if
        if socketstatus equals "+STCPC:1":
            get socketstatus from GPRS module
        end if
        if not received OK from GPRS module:
            return -1
        end if
        if socketstatus not starts with "+SOCKSTATUS":
            return -1
        end if
        if socketstatus packet length equals packetlength:
            break
        else:
            wait for 1000 milliseconds
        end if
    end while
    send "AT+SDATASTATUS=0" to the GPRS module
    send "AT+SDATASTART=1,0" to the GPRS module
    if not received OK from GPRS module:
        return -1
    end if
    send "AT+CGATT=0" to the GPRS module
    if not received OK from GPRS module:
        return -1
    end if
    send "AAT+CGATT?" to the GPRS module
    set connected as false
    return 1
end Function(sendData)
\end{lstlisting}

\subsubsection{Main Runner}

\subsubsection{HTTP Server}

\textit{\textcolor{red}{Description of the design; break into pieces and show how 
                        they assemble.}}

\textit{\textcolor{red}{Pseudo code of important modules}}

\textit{\textcolor{red}{MDD of structure}}

\textit{\textcolor{red}{System diagram}}

\subsection{Safety}
